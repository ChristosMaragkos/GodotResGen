<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/addons/ResourceGen/AbstractResourceProvider.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/addons/ResourceGen/AbstractResourceProvider.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using Godot;&#10;using FileAccess = Godot.FileAccess;&#10;&#10;namespace resourcegenapi.addons.ResourceGen;&#10;&#10;public abstract class AbstractResourceProvider : IDisposable&#10;{&#10;    // Track how many resources were new vs changed for this provider run.&#10;    public abstract void GenerateAndSave(out int newResources, out int changedResources);&#10;&#10;    public void Dispose()&#10;    {&#10;        GC.SuppressFinalize(this);&#10;    }&#10;}&#10;&#10;public abstract class AbstractResourceProvider&lt;T&gt; : AbstractResourceProvider where T : notnull, Resource&#10;{&#10;    protected abstract string GetName();&#10;&#10;    private List&lt;T&gt; Resources { get; } = [];&#10;&#10;    private enum SaveResult&#10;    {&#10;        New,&#10;        Changed,&#10;        Unchanged,&#10;        Failed&#10;    }&#10;&#10;    public override void GenerateAndSave(out int newResources, out int changedResources)&#10;    {&#10;        newResources = 0;&#10;        changedResources = 0;&#10;        ResGenLogger.Log($&quot;Firing up provider: {GetName()}&quot;);&#10;        var folderPath = GetOrCreateOutputDirectory();&#10;        Resources.Clear();&#10;&#10;        Generate();&#10;&#10;        if (Resources.Count == 0)&#10;        {&#10;            ResGenLogger.Log($&quot;No resources generated by provider: {GetName()}. Skipping save.&quot;);&#10;            return;&#10;        }&#10;&#10;        foreach (var resource in Resources)&#10;        {&#10;            var result = SaveOrUpdateResource(resource, folderPath);&#10;            switch (result)&#10;            {&#10;                case SaveResult.New:&#10;                    newResources++;&#10;                    break;&#10;                case SaveResult.Changed:&#10;                    changedResources++;&#10;                    break;&#10;            }&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;Provider summary: New={newResources}, Changed={changedResources}, TotalAffected={newResources + changedResources}, TotalGenerated={Resources.Count}&quot;);&#10;    }&#10;&#10;    private static string GetOrCreateOutputDirectory()&#10;    {&#10;        var path = ConfigManager.GetOutputPath().PathJoin(typeof(T).Name);&#10;&#10;        var dir = DirAccess.Open(&quot;res://&quot;);&#10;        if (dir.DirExists(path)) return path;&#10;        var err = dir.MakeDirRecursive(path);&#10;        if (err != Error.Ok)&#10;        {&#10;            GD.PrintErr($&quot;Failed to create directory: {path}, Error: {err}&quot;);&#10;        }&#10;&#10;        return path;&#10;    }&#10;&#10;    protected void AddResource(T resource)&#10;    {&#10;        if (Resources.Any(r =&gt; r.ResourceName == resource.ResourceName))&#10;        {&#10;            GD.PrintErr(&#10;                $&quot;Resource with name {resource.ResourceName} already exists in provider {GetName()}. Skipping.&quot;);&#10;            return;&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;Resource {resource.ResourceName} of type {resource.GetType().Name} added to provider {GetName()}.&quot;);&#10;        Resources.Add(resource);&#10;    }&#10;&#10;    protected abstract void Generate();&#10;&#10;    private static string SanitizeFileName(string name)&#10;    {&#10;        if (string.IsNullOrWhiteSpace(name))&#10;            return string.Concat(typeof(T).Name, &quot;_&quot;, Guid.NewGuid().ToString(&quot;N&quot;).AsSpan(0, 8));&#10;        var invalid = Path.GetInvalidFileNameChars();&#10;        var cleaned = new string(name.Select(c =&gt; invalid.Contains(c) ? '_' : c).ToArray());&#10;        return cleaned.Replace(' ', '_').ToLowerInvariant();&#10;    }&#10;&#10;    private static SaveResult SaveOrUpdateResource(T generated, string folderPath)&#10;    {&#10;        var fileName = SanitizeFileName(generated.ResourceName) + &quot;.tres&quot;;&#10;        var resourcePath = folderPath.PathJoin(fileName);&#10;        var exists = FileAccess.FileExists(resourcePath);&#10;&#10;        if (!exists)&#10;        {&#10;            ResGenLogger.Log($&quot;[NEW] {resourcePath}&quot;);&#10;            var error = ResourceSaver.Save(generated, resourcePath);&#10;            if (error != Error.Ok)&#10;            {&#10;                ResGenLogger.Log($&quot;Failed to save NEW resource: {generated.ResourceName} to {resourcePath}. Error: {error}&quot;);&#10;                return SaveResult.Failed;&#10;            }&#10;            ResGenLogger.Log($&quot;Resource saved: {generated.ResourceName} to {resourcePath}&quot;);&#10;            return SaveResult.New;&#10;        }&#10;&#10;        var existing = ResourceLoader.Load&lt;T&gt;(resourcePath);&#10;        if (existing == null)&#10;        {&#10;            ResGenLogger.Log($&quot;Existing resource failed to load (will treat as NEW): {resourcePath}&quot;);&#10;            var error2 = ResourceSaver.Save(generated, resourcePath);&#10;            return error2 == Error.Ok ? SaveResult.New : SaveResult.Failed;&#10;        }&#10;&#10;        // Determine if any relevant property differs BEFORE mutating existing.&#10;        if (!IsChanged(existing, generated))&#10;        {&#10;            ResGenLogger.Log($&quot;[UNCHANGED] {resourcePath}&quot;);&#10;            return SaveResult.Unchanged;&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;[CHANGED] {resourcePath}&quot;);&#10;        try&#10;        {&#10;            ApplyValues(generated, existing); // copy into existing instance&#10;            var err = ResourceSaver.Save(existing, resourcePath);&#10;            if (err != Error.Ok)&#10;            {&#10;                ResGenLogger.Log($&quot;Failed to update existing resource: {generated.ResourceName} at {resourcePath}. Error: {err}&quot;);&#10;                return SaveResult.Failed;&#10;            }&#10;            ResGenLogger.Log($&quot;Resource updated: {generated.ResourceName} at {resourcePath}&quot;);&#10;            return SaveResult.Changed;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            GD.PrintErr($&quot;Failed updating existing resource {resourcePath}: {ex.Message}&quot;);&#10;            return SaveResult.Failed;&#10;        }&#10;    }&#10;&#10;    private static bool IsChanged(T existing, T generated)&#10;    {&#10;        var propList = generated.GetPropertyList();&#10;        foreach (var dict in propList)&#10;        {&#10;            if (!dict.TryGetValue(&quot;name&quot;, out var propValue)) continue;&#10;            var name = (string)propValue;&#10;            if (ShouldSkipProperty(name)) continue;&#10;            object oldVal = existing.Get(name);&#10;            object newVal = generated.Get(name);&#10;            if (!Equals(oldVal, newVal))&#10;                return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // Copy editable properties from a newly generated instance to an existing cached one.&#10;    private static void ApplyValues(T source, T target)&#10;    {&#10;        var propList = source.GetPropertyList();&#10;        foreach (var dict in propList)&#10;        {&#10;            if (!dict.TryGetValue(&quot;name&quot;, out var propValue)) continue;&#10;            var name = (string)propValue;&#10;            if (ShouldSkipProperty(name)) continue;&#10;            try&#10;            {&#10;                var value = source.Get(name);&#10;                target.Set(name, value);&#10;            }&#10;            catch&#10;            {&#10;                // Ignore properties that throw (read-only or restricted)&#10;            }&#10;        }&#10;    }&#10;&#10;    private static bool ShouldSkipProperty(string name)&#10;    {&#10;        return name is &quot;resource_path&quot; or &quot;resource_name&quot; or &quot;script&quot;;&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using Godot;&#10;using FileAccess = Godot.FileAccess;&#10;&#10;namespace resourcegenapi.addons.ResourceGen;&#10;&#10;public abstract class AbstractResourceProvider : IDisposable&#10;{&#10;    // Track how many resources were new vs changed for this provider run.&#10;    public abstract void GenerateAndSave(out int newResources, out int changedResources);&#10;&#10;    public void Dispose()&#10;    {&#10;        GC.SuppressFinalize(this);&#10;    }&#10;}&#10;&#10;public abstract class AbstractResourceProvider&lt;T&gt; : AbstractResourceProvider where T : notnull, Resource&#10;{&#10;    protected abstract string GetName();&#10;&#10;    private List&lt;T&gt; Resources { get; } = [];&#10;&#10;    private enum SaveResult&#10;    {&#10;        New,&#10;        Changed,&#10;        Unchanged,&#10;        Failed&#10;    }&#10;&#10;    public override void GenerateAndSave(out int newResources, out int changedResources)&#10;    {&#10;        newResources = 0;&#10;        changedResources = 0;&#10;        ResGenLogger.Log($&quot;Firing up provider: {GetName()}&quot;);&#10;        var folderPath = GetOrCreateOutputDirectory();&#10;        Resources.Clear();&#10;&#10;        Generate();&#10;&#10;        if (Resources.Count == 0)&#10;        {&#10;            ResGenLogger.Log($&quot;No resources generated by provider: {GetName()}. Skipping save.&quot;);&#10;            return;&#10;        }&#10;&#10;        foreach (var resource in Resources)&#10;        {&#10;            var result = SaveOrUpdateResource(resource, folderPath);&#10;            switch (result)&#10;            {&#10;                case SaveResult.New:&#10;                    newResources++;&#10;                    break;&#10;                case SaveResult.Changed:&#10;                    changedResources++;&#10;                    break;&#10;            }&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;Provider summary: New={newResources}, Changed={changedResources}, TotalAffected={newResources + changedResources}, TotalGenerated={Resources.Count}&quot;);&#10;    }&#10;&#10;    private static string GetOrCreateOutputDirectory()&#10;    {&#10;        var path = ConfigManager.GetOutputPath().PathJoin(typeof(T).Name);&#10;&#10;        var dir = DirAccess.Open(&quot;res://&quot;);&#10;        if (dir.DirExists(path)) return path;&#10;        var err = dir.MakeDirRecursive(path);&#10;        if (err != Error.Ok)&#10;        {&#10;            GD.PrintErr($&quot;Failed to create directory: {path}, Error: {err}&quot;);&#10;        }&#10;&#10;        return path;&#10;    }&#10;&#10;    protected void AddResource(T resource)&#10;    {&#10;        if (Resources.Any(r =&gt; r.ResourceName == resource.ResourceName))&#10;        {&#10;            GD.PrintErr(&#10;                $&quot;Resource with name {resource.ResourceName} already exists in provider {GetName()}. Skipping.&quot;);&#10;            return;&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;Resource {resource.ResourceName} of type {resource.GetType().Name} added to provider {GetName()}.&quot;);&#10;        Resources.Add(resource);&#10;    }&#10;&#10;    protected abstract void Generate();&#10;&#10;    private static string SanitizeFileName(string name)&#10;    {&#10;        if (string.IsNullOrWhiteSpace(name))&#10;            return string.Concat(typeof(T).Name, &quot;_&quot;, Guid.NewGuid().ToString(&quot;N&quot;).AsSpan(0, 8));&#10;        var invalid = Path.GetInvalidFileNameChars();&#10;        var cleaned = new string(name.Select(c =&gt; invalid.Contains(c) ? '_' : c).ToArray());&#10;        return cleaned.Replace(' ', '_').ToLowerInvariant();&#10;    }&#10;&#10;    private static SaveResult SaveOrUpdateResource(T generated, string folderPath)&#10;    {&#10;        var fileName = SanitizeFileName(generated.ResourceName) + &quot;.tres&quot;;&#10;        var resourcePath = folderPath.PathJoin(fileName);&#10;        var exists = FileAccess.FileExists(resourcePath);&#10;&#10;        if (!exists)&#10;        {&#10;            ResGenLogger.Log($&quot;[NEW] {resourcePath}&quot;);&#10;            var error = ResourceSaver.Save(generated, resourcePath);&#10;            if (error != Error.Ok)&#10;            {&#10;                ResGenLogger.Log($&quot;Failed to save NEW resource: {generated.ResourceName} to {resourcePath}. Error: {error}&quot;);&#10;                return SaveResult.Failed;&#10;            }&#10;            ResGenLogger.Log($&quot;Resource saved: {generated.ResourceName} to {resourcePath}&quot;);&#10;            return SaveResult.New;&#10;        }&#10;&#10;        var existing = ResourceLoader.Load&lt;T&gt;(resourcePath);&#10;        if (existing == null)&#10;        {&#10;            ResGenLogger.Log($&quot;Existing resource failed to load (will treat as NEW): {resourcePath}&quot;);&#10;            var error2 = ResourceSaver.Save(generated, resourcePath);&#10;            return error2 == Error.Ok ? SaveResult.New : SaveResult.Failed;&#10;        }&#10;&#10;        // Determine if any relevant property differs BEFORE mutating existing.&#10;        if (!IsChanged(existing, generated))&#10;        {&#10;            ResGenLogger.Log($&quot;[UNCHANGED] {resourcePath}&quot;);&#10;            return SaveResult.Unchanged;&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;[CHANGED] {resourcePath}&quot;);&#10;        try&#10;        {&#10;            ApplyValues(generated, existing); // copy into existing instance&#10;            var err = ResourceSaver.Save(existing, resourcePath);&#10;            if (err != Error.Ok)&#10;            {&#10;                ResGenLogger.Log($&quot;Failed to update existing resource: {generated.ResourceName} at {resourcePath}. Error: {err}&quot;);&#10;                return SaveResult.Failed;&#10;            }&#10;            ResGenLogger.Log($&quot;Resource updated: {generated.ResourceName} at {resourcePath}&quot;);&#10;            return SaveResult.Changed;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            GD.PrintErr($&quot;Failed updating existing resource {resourcePath}: {ex.Message}&quot;);&#10;            return SaveResult.Failed;&#10;        }&#10;    }&#10;&#10;    private static bool IsChanged(T existing, T generated)&#10;    {&#10;        var propList = generated.GetPropertyList();&#10;        foreach (var dict in propList)&#10;        {&#10;            if (!dict.TryGetValue(&quot;name&quot;, out var propValue)) continue;&#10;            var name = (string)propValue;&#10;            if (ShouldSkipProperty(name)) continue;&#10;            object oldVal = existing.Get(name);&#10;            object newVal = generated.Get(name);&#10;            if (!Equals(oldVal, newVal))&#10;                return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    // Copy editable properties from a newly generated instance to an existing cached one.&#10;    private static void ApplyValues(T source, T target)&#10;    {&#10;        var propList = source.GetPropertyList();&#10;        foreach (var dict in propList)&#10;        {&#10;            if (!dict.TryGetValue(&quot;name&quot;, out var propValue)) continue;&#10;            var name = (string)propValue;&#10;            if (ShouldSkipProperty(name)) continue;&#10;            try&#10;            {&#10;                var value = source.Get(name);&#10;                target.Set(name, value);&#10;            }&#10;            catch&#10;            {&#10;                // Ignore properties that throw (read-only or restricted)&#10;            }&#10;        }&#10;    }&#10;&#10;    private static bool ShouldSkipProperty(string name)&#10;    {&#10;        return name is &quot;resource_path&quot; or &quot;resource_name&quot; or &quot;script&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/addons/ResourceGen/ProviderManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/addons/ResourceGen/ProviderManager.cs" />
              <option name="originalContent" value="#if TOOLS&#10;using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Reflection;&#10;using Godot;&#10;&#10;namespace resourcegenapi.addons.ResourceGen;&#10;&#10;[Tool]&#10;public static class ProviderManager&#10;{&#10;    private static readonly List&lt;string&gt; ProviderTypeNames = [];&#10;    private static VBoxContainer _container;&#10;&#10;    public static void Initialize(VBoxContainer container)&#10;    {&#10;        _container = container;&#10;    }&#10;&#10;    public static void RefreshProviders()&#10;    {&#10;        if (_container == null)&#10;        {&#10;            GD.PrintErr(&quot;Provider manager not initialized correctly. Please restart the plugin.&quot;);&#10;            return;&#10;        }&#10;        &#10;        ResGenLogger.Clear();&#10;        ClearProviderButtons();&#10;        ProviderTypeNames.Clear();&#10;&#10;        var start = DateTime.Now;&#10;        ResGenLogger.Log($&quot;Time: {start}&quot;);&#10;        ResGenLogger.Log(&quot;Initializing provider discovery...&quot;);&#10;&#10;        var types = AppDomain.CurrentDomain.GetAssemblies()&#10;            .SelectMany(a =&gt;&#10;            {&#10;                try { return a.GetTypes(); }&#10;                catch (ReflectionTypeLoadException rtle) { return rtle.Types.Where(t =&gt; t != null)!; }&#10;            })&#10;            .Where(t =&gt; t is { IsAbstract: false } &amp;&amp;&#10;                        typeof(AbstractResourceProvider).IsAssignableFrom(t));&#10;&#10;        foreach (var t in types)&#10;        {&#10;            var aqn = t.AssemblyQualifiedName;&#10;            if (aqn == null) continue;&#10;            ProviderTypeNames.Add(aqn);&#10;            AddProviderButton(t.Name, aqn);&#10;            ResGenLogger.Log($&quot;Discovered provider: {t.FullName}&quot;);&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;Discovered {ProviderTypeNames.Count} providers.&quot;);&#10;        FinishTask(start);&#10;    }&#10;&#10;    public static void GenerateResources()&#10;    {&#10;        ResGenLogger.Clear();&#10;        var start = DateTime.Now;&#10;&#10;        RefreshProviders();&#10;&#10;        ResGenLogger.Log($&quot;Time: {start}&quot;);&#10;        ResGenLogger.Log(&quot;Starting resource generation...&quot;);&#10;&#10;        if (ProviderTypeNames.Count == 0)&#10;        {&#10;            ResGenLogger.Log(&quot;No providers found.&quot;);&#10;            FinishTask(start);&#10;            return;&#10;        }&#10;&#10;        int totalNew = 0;&#10;        int totalChanged = 0;&#10;&#10;        foreach (var aqn in ProviderTypeNames.ToArray())&#10;        {&#10;            var (newRes, changedRes) = RunSingleProvider(aqn);&#10;            totalNew += newRes;&#10;            totalChanged += changedRes;&#10;        }&#10;&#10;        var totalAffected = totalNew + totalChanged;&#10;        ResGenLogger.Log($&quot;All providers completed. Aggregate summary: New={totalNew}, Changed={totalChanged}, TotalAffected={totalAffected}.&quot;);&#10;        FinishTask(start);&#10;        MaybeWriteLog();&#10;        CleanupAfterRun();&#10;    }&#10;&#10;    private static (int newRes, int changedRes) RunSingleProvider(string assemblyQualifiedName)&#10;    {&#10;        var type = Type.GetType(assemblyQualifiedName, false);&#10;        if (type == null)&#10;        {&#10;            ResGenLogger.Log($&quot;Type not found: {assemblyQualifiedName}&quot;);&#10;            return (0, 0);&#10;        }&#10;&#10;        int newRes = 0;&#10;        int changedRes = 0;&#10;        AbstractResourceProvider instance = null;&#10;        try&#10;        {&#10;            instance = (AbstractResourceProvider)Activator.CreateInstance(type);&#10;            instance?.GenerateAndSave(out newRes, out changedRes);&#10;            ResGenLogger.Log($&quot;Provider {type.Name} completed. New={newRes}, Changed={changedRes}, Affected={newRes + changedRes}&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            ResGenLogger.Log($&quot;Error in {type.FullName}: {ex.Message}&quot;);&#10;        }&#10;        finally&#10;        {&#10;            if (instance is IDisposable d) d.Dispose();&#10;        }&#10;        return (newRes, changedRes);&#10;    }&#10;&#10;    private static void AddProviderButton(string displayName, string aqn)&#10;    {&#10;        if (_container == null)&#10;        {&#10;            GD.PrintErr(&quot;Provider manager not initialized correctly. Please restart the plugin.&quot;);&#10;            return;&#10;        }&#10;        &#10;        var button = new Button&#10;        {&#10;            Text = displayName,&#10;            TooltipText = &quot;Click to run this provider&quot;&#10;        };&#10;        button.SetMeta(&quot;ProviderAqn&quot;, aqn);&#10;        button.Pressed += () =&gt;&#10;        {&#10;            var meta = button.GetMeta(&quot;ProviderAqn&quot;);&#10;            var name = (string)meta;&#10;            ResGenLogger.Clear();&#10;            var start = DateTime.Now;&#10;            ResGenLogger.Log($&quot;Time: {start}&quot;);&#10;            ResGenLogger.Log($&quot;Starting resource generation for provider: {displayName}&quot;);&#10;            var (n, c) = RunSingleProvider(name);&#10;            ResGenLogger.Log($&quot;Provider {displayName} run complete. New={n}, Changed={c}, Affected={n + c}&quot;);&#10;            FinishTask(start);&#10;            MaybeWriteLog();&#10;        };&#10;        _container.AddChild(button);&#10;    }&#10;&#10;    private static void ClearProviderButtons()&#10;    {&#10;        if (_container == null) return;&#10;        &#10;        foreach (var child in _container.GetChildren().OfType&lt;Button&gt;().ToArray())&#10;        {&#10;            _container.RemoveChild(child);&#10;            child.QueueFree();&#10;        }&#10;    }&#10;&#10;    private static void CleanupAfterRun()&#10;    {&#10;        ProviderTypeNames.Clear();&#10;    }&#10;&#10;    private static void MaybeWriteLog()&#10;    {&#10;        if (ConfigManager.ShouldCreateLogFile())&#10;            ResGenLogger.SaveConfigFile();&#10;    }&#10;&#10;    private static void FinishTask(DateTime start)&#10;    {&#10;        var end = DateTime.Now;&#10;        ResGenLogger.Log($&quot;Task completed in {(end - start).TotalSeconds} seconds.&quot;);&#10;    }&#10;}&#10;#endif" />
              <option name="updatedContent" value="#if TOOLS&#10;using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Reflection;&#10;using Godot;&#10;&#10;namespace resourcegenapi.addons.ResourceGen;&#10;&#10;[Tool]&#10;public static class ProviderManager&#10;{&#10;    private static readonly List&lt;string&gt; ProviderTypeNames = [];&#10;    private static VBoxContainer _container;&#10;&#10;    public static void Initialize(VBoxContainer container)&#10;    {&#10;        _container = container;&#10;    }&#10;&#10;    public static void RefreshProviders()&#10;    {&#10;        if (_container == null)&#10;        {&#10;            GD.PrintErr(&quot;Provider manager not initialized correctly. Please restart the plugin.&quot;);&#10;            return;&#10;        }&#10;        &#10;        ResGenLogger.Clear();&#10;        ClearProviderButtons();&#10;        ProviderTypeNames.Clear();&#10;&#10;        var start = DateTime.Now;&#10;        ResGenLogger.Log($&quot;Time: {start}&quot;);&#10;        ResGenLogger.Log(&quot;Initializing provider discovery...&quot;);&#10;&#10;        var types = AppDomain.CurrentDomain.GetAssemblies()&#10;            .SelectMany(a =&gt;&#10;            {&#10;                try { return a.GetTypes(); }&#10;                catch (ReflectionTypeLoadException rtle) { return rtle.Types.Where(t =&gt; t != null)!; }&#10;            })&#10;            .Where(t =&gt; t is { IsAbstract: false } &amp;&amp;&#10;                        typeof(AbstractResourceProvider).IsAssignableFrom(t));&#10;&#10;        foreach (var t in types)&#10;        {&#10;            var aqn = t.AssemblyQualifiedName;&#10;            if (aqn == null) continue;&#10;            ProviderTypeNames.Add(aqn);&#10;            AddProviderButton(t.Name, aqn);&#10;            ResGenLogger.Log($&quot;Discovered provider: {t.FullName}&quot;);&#10;        }&#10;&#10;        ResGenLogger.Log($&quot;Discovered {ProviderTypeNames.Count} providers.&quot;);&#10;        FinishTask(start);&#10;    }&#10;&#10;    public static void GenerateResources()&#10;    {&#10;        ResGenLogger.Clear();&#10;        var start = DateTime.Now;&#10;&#10;        RefreshProviders();&#10;&#10;        ResGenLogger.Log($&quot;Time: {start}&quot;);&#10;        ResGenLogger.Log(&quot;Starting resource generation...&quot;);&#10;&#10;        if (ProviderTypeNames.Count == 0)&#10;        {&#10;            ResGenLogger.Log(&quot;No providers found.&quot;);&#10;            FinishTask(start);&#10;            return;&#10;        }&#10;&#10;        int totalNew = 0;&#10;        int totalChanged = 0;&#10;&#10;        foreach (var aqn in ProviderTypeNames.ToArray())&#10;        {&#10;            var (newRes, changedRes) = RunSingleProvider(aqn);&#10;            totalNew += newRes;&#10;            totalChanged += changedRes;&#10;        }&#10;&#10;        var totalAffected = totalNew + totalChanged;&#10;        ResGenLogger.Log($&quot;All providers completed. Aggregate summary: New={totalNew}, Changed={totalChanged}, TotalAffected={totalAffected}.&quot;);&#10;        FinishTask(start);&#10;        MaybeWriteLog();&#10;        CleanupAfterRun();&#10;    }&#10;&#10;    private static (int newRes, int changedRes) RunSingleProvider(string assemblyQualifiedName)&#10;    {&#10;        var type = Type.GetType(assemblyQualifiedName, false);&#10;        if (type == null)&#10;        {&#10;            ResGenLogger.Log($&quot;Type not found: {assemblyQualifiedName}&quot;);&#10;            return (0, 0);&#10;        }&#10;&#10;        int newRes = 0;&#10;        int changedRes = 0;&#10;        AbstractResourceProvider instance = null;&#10;        try&#10;        {&#10;            instance = (AbstractResourceProvider)Activator.CreateInstance(type);&#10;            instance?.GenerateAndSave(out newRes, out changedRes);&#10;            ResGenLogger.Log($&quot;Provider {type.Name} completed. New={newRes}, Changed={changedRes}, Affected={newRes + changedRes}&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            ResGenLogger.Log($&quot;Error in {type.FullName}: {ex.Message}&quot;);&#10;        }&#10;        finally&#10;        {&#10;            if (instance is IDisposable d) d.Dispose();&#10;        }&#10;        return (newRes, changedRes);&#10;    }&#10;&#10;    private static void AddProviderButton(string displayName, string aqn)&#10;    {&#10;        if (_container == null)&#10;        {&#10;            GD.PrintErr(&quot;Provider manager not initialized correctly. Please restart the plugin.&quot;);&#10;            return;&#10;        }&#10;        &#10;        var button = new Button&#10;        {&#10;            Text = displayName,&#10;            TooltipText = &quot;Click to run this provider&quot;&#10;        };&#10;        button.SetMeta(&quot;ProviderAqn&quot;, aqn);&#10;        button.Pressed += () =&gt;&#10;        {&#10;            var meta = button.GetMeta(&quot;ProviderAqn&quot;);&#10;            var name = (string)meta;&#10;            ResGenLogger.Clear();&#10;            var start = DateTime.Now;&#10;            ResGenLogger.Log($&quot;Time: {start}&quot;);&#10;            ResGenLogger.Log($&quot;Starting resource generation for provider: {displayName}&quot;);&#10;            var (n, c) = RunSingleProvider(name);&#10;            ResGenLogger.Log($&quot;Provider {displayName} run complete. New={n}, Changed={c}, Affected={n + c}&quot;);&#10;            FinishTask(start);&#10;            MaybeWriteLog();&#10;        };&#10;        _container.AddChild(button);&#10;    }&#10;&#10;    private static void ClearProviderButtons()&#10;    {&#10;        if (_container == null) return;&#10;        &#10;        foreach (var child in _container.GetChildren().OfType&lt;Button&gt;().ToArray())&#10;        {&#10;            _container.RemoveChild(child);&#10;            child.QueueFree();&#10;        }&#10;    }&#10;&#10;    private static void CleanupAfterRun()&#10;    {&#10;        ProviderTypeNames.Clear();&#10;    }&#10;&#10;    private static void MaybeWriteLog()&#10;    {&#10;        if (ConfigManager.ShouldCreateLogFile())&#10;            ResGenLogger.SaveConfigFile();&#10;    }&#10;&#10;    private static void FinishTask(DateTime start)&#10;    {&#10;        var end = DateTime.Now;&#10;        ResGenLogger.Log($&quot;Task completed in {(end - start).TotalSeconds} seconds.&quot;);&#10;    }&#10;}&#10;#endif" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>