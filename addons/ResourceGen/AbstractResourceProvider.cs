using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Godot;
using FileAccess = Godot.FileAccess;

namespace ResourceGenerationFramework.ResourceGen;

//Hey you! Yes, you! If you're reading this, you're probably interested in creating your own resource providers.
//That's awesome! This abstract class is designed to make it easier for you to create and manage resources in Godot.
//Here's a quick guide on how to use it:
//1. Inherit from AbstractResourceProvider<T>: Create a new class that inherits from AbstractResourceProvider<T>,
//   where T is the type of Resource you want to manage (e.g., Texture, AudioStream, etc.).
//2. Implement GetName(): This method should return a string that represents the name of your provider.
//3. Implement Generate(): This method is where you'll generate and add your resources using the AddResource(T resource) method.
//4. Use AddResource(T resource): Call this method to add resources to the provider. It ensures that resources with duplicate names are not added.
//5. Resource Saving: The GenerateAndSave method handles saving resources to disk, checking for changes, and
//   logging the results.
//6. Dispose: The class implements IDisposable, so you can clean up resources if needed.
//Remember to handle exceptions and edge cases as needed in your implementation. Happy coding!
public abstract class AbstractResourceProvider : IDisposable
{
    // Track how many resources were new vs changed for this provider run.
    public abstract void GenerateAndSave(out int newResources, out int changedResources);

    public void Dispose()
    {
        GC.SuppressFinalize(this);
    }
}

public abstract class AbstractResourceProvider<T> : AbstractResourceProvider where T : notnull, Resource
{
    protected abstract string GetName();

    private List<T> Resources { get; } = [];

    private enum SaveResult
    {
        New,
        Changed,
        Unchanged,
        Failed
    }

    public override void GenerateAndSave(out int newResources, out int changedResources)
    {
        newResources = 0;
        changedResources = 0;
        ResGenLogger.Log($"Firing up provider: {GetName()}");
        var folderPath = GetOrCreateOutputDirectory();
        Resources.Clear();

        Generate();

        if (Resources.Count == 0)
        {
            ResGenLogger.Log($"No resources generated by provider: {GetName()}. Skipping save.");
            return;
        }

        foreach (var result in Resources.Select(resource => SaveOrUpdateResource(resource, folderPath)))
        {
            switch (result)
            {
                case SaveResult.New:
                    newResources++;
                    break;
                case SaveResult.Changed:
                    changedResources++;
                    break;
                case SaveResult.Unchanged:
                case SaveResult.Failed:
                default:
                    break;
            }
        }
    }

    private static string GetOrCreateOutputDirectory()
    {
        var path = ConfigManager.GetOutputPath().PathJoin(typeof(T).Name);

        var dir = DirAccess.Open("res://");
        if (dir.DirExists(path)) return path;
        var err = dir.MakeDirRecursive(path);
        if (err != Error.Ok)
        {
            GD.PrintErr($"Failed to create directory: {path}, Error: {err}");
        }

        return path;
    }

    protected void AddResource(T resource)
    {
        if (Resources.Any(r => r.ResourceName == resource.ResourceName))
        {
            GD.PrintErr(
                $"Resource with name {resource.ResourceName} already exists in provider {GetName()}. Skipping.");
            return;
        }

        ResGenLogger.Log($"Resource {resource.ResourceName} of type {resource.GetType().Name} added to provider {GetName()}.");
        Resources.Add(resource);
    }

    protected abstract void Generate();

    private static string SanitizeFileName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return string.Concat(typeof(T).Name, "_", Guid.NewGuid().ToString("N").AsSpan(0, 8));
        var invalid = Path.GetInvalidFileNameChars();
        var cleaned = new string(name.Select(c => invalid.Contains(c) ? '_' : c).ToArray());
        return cleaned.Replace(' ', '_').ToLowerInvariant();
    }

    private static SaveResult SaveOrUpdateResource(T generated, string folderPath)
    {
        var fileName = SanitizeFileName(generated.ResourceName) + ".tres";
        var resourcePath = folderPath.PathJoin(fileName);
        var exists = FileAccess.FileExists(resourcePath);

        if (!exists)
        {
            ResGenLogger.Log($"[NEW] {resourcePath}");
            var error = ResourceSaver.Save(generated, resourcePath);
            if (error != Error.Ok)
            {
                ResGenLogger.Log($"Failed to save NEW resource: {generated.ResourceName} to {resourcePath}. Error: {error}");
                return SaveResult.Failed;
            }
            ResGenLogger.Log($"Resource saved: {generated.ResourceName} to {resourcePath}");
            return SaveResult.New;
        }

        var existing = ResourceLoader.Load<T>(resourcePath);

        // Determine if any relevant property differs BEFORE mutating existing.
        if (!IsChanged(existing, generated))
        {
            ResGenLogger.Log($"[UNCHANGED] {resourcePath}");
            return SaveResult.Unchanged;
        }

        ResGenLogger.Log($"[CHANGED] {resourcePath}");
        try
        {
            ApplyValues(generated, existing); // copy into existing instance
            var err = ResourceSaver.Save(existing, resourcePath);
            if (err != Error.Ok)
            {
                ResGenLogger.Log($"Failed to update existing resource: {generated.ResourceName} at {resourcePath}. Error: {err}");
                return SaveResult.Failed;
            }
            ResGenLogger.Log($"Resource updated: {generated.ResourceName} at {resourcePath}");
            return SaveResult.Changed;
        }
        catch (Exception ex)
        {
            GD.PrintErr($"Failed updating existing resource {resourcePath}: {ex.Message}");
            return SaveResult.Failed;
        }
    }

    private static bool IsChanged(T existing, T generated)
    {
        var propList = generated.GetPropertyList();
        foreach (var dict in propList)
        {
            if (!dict.TryGetValue("name", out var propValue)) continue;
            var name = (string)propValue;
            if (ShouldSkipProperty(name)) continue;
            object oldVal = existing.Get(name);
            object newVal = generated.Get(name);
            if (!Equals(oldVal, newVal))
                return true;
        }
        return false;
    }

    // Copy editable properties from a newly generated instance to an existing cached one.
    private static void ApplyValues(T source, T target)
    {
        var propList = source.GetPropertyList();
        foreach (var dict in propList)
        {
            if (!dict.TryGetValue("name", out var propValue)) continue;
            var name = (string)propValue;
            if (ShouldSkipProperty(name)) continue;
            try
            {
                var value = source.Get(name);
                target.Set(name, value);
            }
            catch
            {
                // Ignore properties that throw (read-only or restricted)
            }
        }
    }

    private static bool ShouldSkipProperty(string name)
    {
        return name is "resource_path" or "resource_name" or "script";
    }
}